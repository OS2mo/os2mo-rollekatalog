# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from collections.abc import Generator
from typing import NewType
from typing import Protocol
from typing import Sequence
from typing import TypeVar
from uuid import UUID

from httpx import AsyncClient
from pydantic import AnyHttpUrl

from os2mo_rollekatalog.autogenerated_graphql_client.get_person import (
    GetPersonEmployeesObjectsCurrentItusers,
)


T = TypeVar("T", covariant=True)


class WillNotSync(Exception):
    def __init__(self, message: str):
        self.message = message


class NoSuitableSamAccount(Exception): ...


class HasUserKey(Protocol):
    user_key: str


class HasUUID(Protocol):
    uuid: UUID


class OrgWithAncestors(HasUUID, Protocol):
    @property
    def ancestors(self) -> Sequence[HasUUID]: ...


class HasValidities(Protocol[T]):
    @property
    def validities(self) -> Sequence[T]: ...


class HasObjects(Protocol[T]):
    @property
    def objects(self) -> Sequence[T]: ...


def flatten_validities(
    something: HasObjects[HasValidities[T]],
) -> Generator[T, None, None]:
    for obj in something.objects:
        for validity in obj.validities:
            yield validity


LDAPClient = NewType("LDAPClient", AsyncClient)


def create_ldap_client(ldap_url: AnyHttpUrl) -> LDAPClient:
    return LDAPClient(AsyncClient(base_url=ldap_url))


def resolve_samaccounts(
    itusers: list[GetPersonEmployeesObjectsCurrentItusers],
    itsystem_user_keys: list[str],
):
    """Pick proper SAM-Account.

    Picking the proper SAM-Account is shared behaviour when creating Users and
    Managers. This function is essentially just here so whoever implements this
    in the future notice that its for people _and_ managers.

    It also implements a "strategy pattern". For now we use ask the LDAP
    integration for the sam account (this is what the old integration did).
    When the LDAP integration supports multiple accounts, we need to pick the
    proper one from MO.
    """
    ad_itusers = [it for it in itusers if it.itsystem.user_key == itsystem_user_keys[0]]
    if not ad_itusers:
        return
    fk_itusers = {
        it.user_key: it
        for it in itusers
        if it.itsystem.user_key == itsystem_user_keys[1]
    }

    for ad in ad_itusers:
        fk = fk_itusers.get(ad.user_key)
        if fk:
            ad.external_id = fk.external_id

    return ad_itusers


def in_org_tree(root_org_unit: UUID, org_unit: OrgWithAncestors) -> bool:
    if root_org_unit == org_unit.uuid:
        return True
    return root_org_unit in {ancestor.uuid for ancestor in org_unit.ancestors}
