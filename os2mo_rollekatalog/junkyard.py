# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from collections.abc import Generator
from typing import NewType
from typing import Protocol
from typing import Sequence
from typing import TypeVar
from uuid import UUID
from datetime import datetime
from zoneinfo import ZoneInfo
from collections import defaultdict
from more_itertools import one

from httpx import AsyncClient
from pydantic import AnyHttpUrl

from os2mo_rollekatalog.autogenerated_graphql_client.get_person import (
    GetPersonEmployeesObjectsCurrentItusers,
)


T = TypeVar("T", covariant=True)


class WillNotSync(Exception):
    def __init__(self, message: str):
        self.message = message


class NoSuitableSamAccount(Exception): ...


class HasUserKey(Protocol):
    user_key: str


class HasUUID(Protocol):
    uuid: UUID


class OrgWithAncestors(HasUUID, Protocol):
    @property
    def ancestors(self) -> Sequence[HasUUID]: ...


class HasValidities(Protocol[T]):
    @property
    def validities(self) -> Sequence[T]: ...


class HasObjects(Protocol[T]):
    @property
    def objects(self) -> Sequence[T]: ...


def flatten_validities(
    something: HasObjects[HasValidities[T]],
) -> Generator[T, None, None]:
    for obj in something.objects:
        for validity in obj.validities:
            yield validity


LDAPClient = NewType("LDAPClient", AsyncClient)


def create_ldap_client(ldap_url: AnyHttpUrl) -> LDAPClient:
    return LDAPClient(AsyncClient(base_url=ldap_url))


def resolve_samaccounts(
    itusers: list[GetPersonEmployeesObjectsCurrentItusers],
    ad_itsystem_user_key: str,
    fk_itsystem_user_key: str,
) -> list[GetPersonEmployeesObjectsCurrentItusers]:
    """
    Resolve SAM accounts for IT-users.

    For each AD IT-user, if their `external_id` matches an FK IT-user's `user_key`,
    the AD user's `external_id` is updated to the FK user's `external_id`.

    Returns a list of AD IT-users with updated `external_id` where applicable.
    Returns an empty list if no AD users exist.
    """
    ad_itusers = [it for it in itusers if it.itsystem.user_key == ad_itsystem_user_key]
    if not ad_itusers:
        return []

    fk_itusers = {
        it.user_key: it
        for it in itusers
        if it.itsystem.user_key == fk_itsystem_user_key
    }

    for ad in ad_itusers:
        fk = fk_itusers.get(ad.external_id) if ad.external_id else None
        if fk:
            ad.external_id = fk.external_id

    return ad_itusers


def select_relevant_itusers(
    itusers: list[GetPersonEmployeesObjectsCurrentItusers],
) -> list[GetPersonEmployeesObjectsCurrentItusers]:
    """
    Pick the current version of each IT-user if available,
    otherwise pick the earliest future version.
    """

    now = datetime.now(ZoneInfo("Europe/Copenhagen"))
    grouped: dict[UUID, list[GetPersonEmployeesObjectsCurrentItusers]] = defaultdict(
        list
    )
    for ituser in itusers:
        grouped[ituser.uuid].append(ituser)

    result: list[GetPersonEmployeesObjectsCurrentItusers] = []

    for uuid, versions in grouped.items():
        # Pick current ituser
        current = [
            it
            for it in versions
            if it.validity.from_ <= now
            and (it.validity.to is None or now < it.validity.to)
        ]

        if current:
            result.append(one(current))
            continue

        # Otherwise pick the soonest future version, if any
        future = [it for it in versions if it.validity.from_ > now]
        if future:
            result.append(min(future, key=lambda it: it.validity.from_))

    return result
